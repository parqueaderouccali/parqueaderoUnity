/*
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

def helpText = """
This Gradle script performs the following:
- Adds Android maven repositories to search locations for artifacts.
- Adds user specified maven repositories to search locations for artifacts.
- Copies specified set of maven artifacts to the specified output directory.
- Displays the set of files copied into the output directory.
- Displays any packages that were not found.

./gradlew -b """ + project.buildscript.sourceFile + """ \\
  \"-PMAVEN_REPOS=[semicolon separated list of repo URIs]\" \\
  \"-PPACKAGES_TO_COPY=[semicolon separated list of maven artifacts]\" \\
  -PTARGET_DIR=[target directory]

ANDROID_HOME (optional env var, system property or project property):
  Optional environment variable, system property or project project that
  specifies the install location of the Android SDK.
MAVEN_REPOS (optional project property):
  Optional property which adds to the list of Maven repositories to search.
  This is a semicolon separated list of URIs e.g
  \"-PMAVEN_REPOS=http://some.repos.com;file:///some/other/path\"
  Since this property semicolon separated it needs to be quoted correctly
  when specified via some command line shells.
USE_MAVEN_LOCAL_REPO (optional project property):
  Optional property which, when not set to 1, disables the implicit use of local
  maven repositories (see mavenLocal() in the gradle docs).
  By default local maven repositories are enabled.
USE_REMOTE_MAVEN_REPOS (optional project property):
  Optional property which, when not set to 1, disables the implicit use of
  remote repositories (maven.google.com, jcenter and maven central) when
  fetching artifacts.  By default remote repositories are enabled.
PACKAGES_TO_COPY (required project property):
  Semicolon separated list of Maven artifact specifications.  This will
  result in the script attempting to download the set of artifacts to
  TARGET_DIR.  Specified artifacts that are not copied to the target directory
  are logged to the standard output stream.
  e.g
  \"-PPACKAGES_TO_COPY=com.android.support:support-compat:26.0.1;\
com.android.support:support-core-utils:26.0.1\"
  Since this property semicolon separated it needs to be quoted correctly
  when specified via some command line shells.
TARGET_DIR (required project property):
  Directory to copy artifacts to.
  e.g -PTARGET_DIR=some/directory/to/copy/to
"""

buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
  }
}

configurations {
  // Configuration used to aggregate the set of packages we'll copy.
  copyPackagesConfig
}

/*
 * Extract the components of a package specifier.
 *
 * @param packageSpecifier Package specification.
 *   Package specification should match agroup:apackage:version@artifacttype
 *   e.g a.b.c:d.e:1.2.3@aar
 *
 * @returns [group, artifact, version, artifactType] list with the components
 * of the package spec.  If a component is not present the entry in the list is
 * null.
 */
List<String> getComponentsFromPackage(String packageSpecifier) {
  def components = [null, null, null, null]
  if (packageSpecifier) {
    packageSpecifier.split(":").eachWithIndex() { component, index ->
      components[index] = component
    }
    if (components[2]) {
      def versionArtifact = components[2].split("@")
      if (versionArtifact.size() == 2) {
        components[2] = versionArtifact[0]
        components[3] = versionArtifact[1]
      }
    }
  }
  return components
}

/*
 * Convert a package specifier to a versionless artifact filename.
 * Incomplete package specifiers result in this method returning null.
 *
 * @param packageSpecifier Package specification.
 * @param colonAsSeparator If true ":" is used as the group, name seperator
 * "." is used otherwise.
 *
 * @returns Versionless artifact filename.
 */
String getVersionlessArtifactByPackage(String packageSpecifier,
                                       boolean colonAsSeparator=false) {
  def (group, artifact, version, artifactType) =
    getComponentsFromPackage(packageSpecifier)
  if (artifact == null) return null
  return [group, artifact].join(colonAsSeparator ? ":" : ".")
}

/*
 * From a set of package specifiers generate a dictionary of versionless
 * artifact filenames (e.g com.example:my-package:1.2.3 would become
 *`ret[com.example:my-package:1.2.3] = "com.example.my-package"`).
 * Incomplete package specifications e.g "com.example" are ignored.
 *
 * @param packages List of package specifier strings.
 * @param colonAsSeparator If true ":" is used as the group, name seperator
 * "." is used otherwise.
 *
 * @returns A map of versionless artifacts by package specifier.
 */
Map<String, String> getVersionlessArtifactsByPackage(
    Iterable<String> packages, boolean colonAsSeparator=false) {
  def versionlessArtifactByPackage = [:]
  packages.each {
    def versionlessArtifact =
      getVersionlessArtifactByPackage(it, colonAsSeparator)
    if (versionlessArtifact) {
      versionlessArtifactByPackage[it] = versionlessArtifact
    }
  }
  return versionlessArtifactByPackage
}

/*
 * From a set of package specifiers dictionary of package names indexed
 * by group:artifact strings (e.g, com.example:my-package:1.2.3@aar would
 * become ret[com.example:my-package] = "com.example:my-package:1.2.3@aar")
 * Package specifiers without at least a group and artifact are ignored.
 *
 * If multiple versions of the same package are specified, the highest version
 * is returned in the map.
 *
 * @param packages List of package specifier strings.
 *
 * @returns A map of package specifiers by group:name tuples.
 */
Map<String, String> getPackagesByVersionlessArtifact(
    Iterable<String> packages) {
  def packagesByVersionlessArtifact = [:]
  packages.each {
    def versionlessArtifact =
      getVersionlessArtifactByPackage(it, true)
    if (versionlessArtifact) {
      def highestVersionPackage = it
      // If the package has already been seen, select the highest version.
      def otherPackageSpec = packagesByVersionlessArtifact[versionlessArtifact]
      if (otherPackageSpec) {
        def packageSpecByVersion =
          [it, otherPackageSpec].collectEntries { pkg ->
            def versionExpression = getComponentsFromPackage(pkg)[2]
            def version = maxVersionFromVersionExpression(
              versionExpression ? versionExpression : "")
            return [version ? version : "0", pkg]
        }
        highestVersionPackage = packageSpecByVersion[
          sortVersionStrings(packageSpecByVersion.keySet())[-1]]
      }
      packagesByVersionlessArtifact[versionlessArtifact] = highestVersionPackage
    }
  }
  return packagesByVersionlessArtifact
}

/*
 * Convert ResolvedModuleVersion to a package specifier string.
 * overrideVersion can be used to replace the version string.
 *
 * @param resolvedModuleVersion Module version to convert to a string.
 * @param overrideVersion If specified, overrides the version in the returned
 * string.
 *
 * @returns Package specifier string.
 */
String resolvedModuleVersionToPackage(
    ResolvedModuleVersion resolvedModuleVersion,
    String overrideVersion=null) {
  def components = []
  resolvedModuleVersion.id.with {
    module.with {
      components.add(group)
      components.add(name)
    }
    if (overrideVersion) {
      components.add(overrideVersion)
    } else {
      components.add(version)
    }
  }
  return components.join(":")
}

/*
 * Convert a ResolvedArtifact object to a package specifier string.
 *
 * @param resolvedArtifact Artifact to convert to a string.
 *
 * @returns String package specifier.
 */
String resolvedArtifactToPackage(ResolvedArtifact resolvedArtifact) {
  def packageSpecifier = resolvedModuleVersionToPackage(
    resolvedArtifact.moduleVersion)
  resolvedArtifact.with { if (type) packageSpecifier += "@" + type }
  return packageSpecifier
}

/*
 * Given a set of ResolvedArtifact objects, generate a set of versionless
 * artifact filenames.
 *
 * @param artifacts List of artifacts to query.
 * @param colonAsSeparator If true ":" is used as the group, name seperator
 * "." is used otherwise.
 *
 * @returns A set of versioned artifact filenames.
 */
Set<String> getVersionlessArtifactFilenames(
    Iterable<ResolvedArtifact> artifacts, boolean colonAsSeparator=false) {
  return (artifacts.collect {
            getVersionlessArtifactByPackage(resolvedArtifactToPackage(it),
                                            colonAsSeparator)
          }).toSet()
}

/*
 * Sort a list of version strings.
 *
 * @param versions Versions to sort.
 *
 * @returns A list of version strings ordered by oldest to most recent version.
 */
List<String> sortVersionStrings(Iterable<String> versions) {
  def versionsList = versions.collect { it }
  // The following sorts by comparing the indices of the versions.
  // If all common indices match, the longer of the two is more recent.
  return versionsList.sort(false) {
    a, b -> [a, b]*.tokenize('.')*.collect { it.tokenize('-')[0] as int }.with {
      u, v -> [u, v].transpose().findResult {
        x, y -> x <=> y ?: null } ?: u.size() <=> v.size()
    }
  }
}

// Type of version expression match.
public enum VersionExpressionMatchType {
  NONE, // No match
  MINIMUM_OF_RANGE, // Minimum version in a range of versions.
  ABSOLUTE, // Absolute version expression specified.
  MINIMUM_VALUE, // Minimum version of a min-version expression.
}

/*
 * Get the minimum version from a maven / ivy version expression.
 *
 * @param versionExpression Version expression to parse.
 *
 * @returns Tuple of minimum version component from the version expression
 * and the type of match
 */
def minimumFromVersionExpression(String versionExpression) {
  // Match Maven / Ivy version range expressions like:
  // [1.2.3,4.5.6]
  // [1.2.3,4.5.6)
  // (1.2.3,4.5.6)
  // (1.2.3,]
  // [,4.5.6)
  def versionRangeMatch = (versionExpression =~
                           /^([\[\(])([^,]*),([^\]\)]*)([\)\]])$/)
  // Match absolute Maven / Ivy version expressions like [1.2.3].
  def absoluteVersionMatch = (versionExpression =~ /^\[([^\]]+)\]$/)
  // Match min value Maven version expressions (i.e which don't start with
  // [ or (.
  def minVersionMatch = (versionExpression =~ /^([^\[\(]+)$/)
  def minVersion = "+"
  VersionExpressionMatchType matchType
  if (versionRangeMatch.matches()) {
    matchType = VersionExpressionMatchType.MINIMUM_OF_RANGE
    minVersion = versionRangeMatch.group(2)
  } else if (absoluteVersionMatch.matches()) {
    matchType = VersionExpressionMatchType.ABSOLUTE
    minVersion = absoluteVersionMatch.group(1)
  } else if (minVersionMatch.matches()) {
    matchType = VersionExpressionMatchType.MINIMUM_VALUE
    minVersion = minVersionMatch.group(1)
  } else {
    matchType = VersionExpressionMatchType.NONE
    logger.error(sprintf("Invalid version expression %s, returning %s",
                         versionExpression, minVersion))
  }
  return [minVersion, matchType]
}

/*
 * Extract components of the minimum value of a version expression.
 *
 * @param versionExpression Version expression to split into components.
 *
 * @return Components of a version number where index 0 is the major component.
 */
List<String> splitMinimumVersionExpression(String versionExpression) {
  return minimumFromVersionExpression(versionExpression)[0].split("\\.")
}

/*
 * Get the absolute version from an artifact version.
 *
 * Gradle can report selected artifacts with absolute version expressions or
 * just version numbers so normalize to a version number.
 *
 * @param version Version to normalize.
 *
 * @return Normalized version number.
 */
String normalizeVersion(String version) {
  def minVersion
  def matchType
  (minVersion, matchType) = minimumFromVersionExpression(version)
  return matchType == VersionExpressionMatchType.ABSOLUTE ? minVersion : version
}

/*
 * Given a maven / ivy version expression string, return an expression that
 * has looser requirements accepting any patch, revision then finally version
 * starting at the current version.
 *
 * @param versionExpression Version expression string to loosen.
 *
 * @returns Loosened version expression string if possible or the original
 * versionExpression.
 */
String loosenVersionExpression(String versionExpression) {
  def components = splitMinimumVersionExpression(versionExpression)
  def lastComponentIndex = components.size() - 1
  if (lastComponentIndex >= 0) {
    def lastComponent = components[lastComponentIndex]
    if (lastComponent == "+") {
      lastComponent =
        (lastComponentIndex > 0 ? components[lastComponentIndex - 1] : "") + "+"
      lastComponentIndex--
    } else if (lastComponent.endsWith("+")) {
      lastComponent = "+"
    } else {
      lastComponent = lastComponent + "+"
    }
    components =
      lastComponentIndex > 0 ? components[0 .. lastComponentIndex - 1] : []
    if (lastComponent) components.add(lastComponent)
  }
  return components ? components.join(".") : "+"
}

/*
 * Replace the wildcard character "+" from a minimum version expression with
 * Integer.MAX_VALUE.
 *
 * This facilitates sorting version expressions with wildcard values after
 * non-wildcard card values.  For example, 1.2.+ will be ordered after 1.2.0.
 *
 * @param versionExpression Expression like 1.2.+
 *
 * @return Returns a version number with the wildcard component replaced by
 * Integer.MAX_VALUE.
 */
String maxVersionFromVersionExpression(String versionExpression) {
  def versionNumberComponents = []
  for (def component in splitMinimumVersionExpression(versionExpression)) {
    if (component.contains("+")) {
      versionNumberComponents.add(
        (Integer.MAX_VALUE - (component == "+" ? 0 : 1)).toString())
      break
    }
    versionNumberComponents.add(component)
  }
  return versionNumberComponents.join(".")
}

/*
 * Convert a module component selector to a string.
 *
 * @param moduleComponentSelector to convert to a string.
 *
 * @return String in the form group:name:version.
 */
String moduleComponentSelectorToString(
    ModuleComponentSelector moduleComponentSelector) {
  def components = []
  moduleComponentSelector.with {
    components.add(group)
    components.add(module)
    components.add(version)
  }
  return components.join(":")
}

/*
 * Get the group of a version-locked package.
 *
 * @param packageSpecifier Package spec to query.
 *
 * @returns 0 if the package isn't version locked, index value greater than 0
 * if the package is added to the lockedPackages list or an index value lesser
 * than 0 if the package is part of a version locked set but is at a non-version
 * locked version.  For example, if a:b.c:1.0 is version locked and a:b.c:2.0
 * is not version locked - 1.0 & 2.0 are arbitrary versions - this will return a
 * positive index value for a:b.c:1.0 and negative value for a:b.c:2.0.
 */
Integer getVersionLockedPackageIndex(String packageSpecifier) {
  // Packages that should be version-locked.
  for (def indexAndRegex in [
         // * com.google.android.gms.* packages are released a single set that
         //   typically are not compatible between revisions.  e.g If a user depends
         //   upon play-services-games:9.8.0 they'll also require
         //   play-services-base:9.8.0 etc.
         // * com.google.firebase.* packages are versioned in the same way as
         //   com.google.android.gms.* with dependencies upon the gms
         //   (Play Services) components. and need to be pinned to the same
         //   com.google.android.gms.* packages.
         ~/^com\.google\.(android\.gms|firebase):.*/,
         // com.android.support packages all need to be included at the same
         // revision.
         ~/^com\.android\.support:.*/,
       ].withIndex()) {
    def (versionLockedRegex, index) = indexAndRegex
    if (!(packageSpecifier ==~ versionLockedRegex)) continue
    // com.google.firebase.* packages that end with -unity$ are shipped
    // separately so they are *not* locked to Google Play services and
    // Firebase packages.
    if (packageSpecifier ==~ /^com\.google\.firebase:[^:]+-unity:.*/) {
      continue
    }
    // Version 15+ of Google Play Services components are released and
    // versioned individually.
    def (group, artifact, version, artifactType) =
      getComponentsFromPackage(packageSpecifier)
    if (group && group ==~ /^com\.google\.(android\.gms|firebase)$/ &&
        version) {
      def majorVersion =
        maxVersionFromVersionExpression(
          splitMinimumVersionExpression(version)[0])
      if (Integer.parseInt(majorVersion) >= 15) {
        return -(index + 1)
      }
    }
    return index + 1
  }
  return 0
}

/*
 * If the specified package is version-locked add it to the appropriate set.
 *
 * @param packageSpecifier Package to add to a set if is version-locked.
 * A version-locked package is determined by a return value of >= 0 by
 * getVersionLockedPackageIndex().
 * @param lockedPackages Map of sets of version-locked packages.  Each set
 * is indexed by the value returned by getVersionLockedPackageIndex().
 * @param blacklist Set of package set indexes that should not be used.
 * This is utilized when a non-version locked package exists in the set of
 * dependencies for a package and therefore no packages in the set should be
 * locked to a specific version.
 *
 * @returns 0 if the package isn't version locked, index value greater than 0
 * if the package is added to the lockedPackages list or an index value lesser
 * than 0 if the package is part of a version locked set but is at a non-version
 * locked version.  For example, if a:b.c:1.0 is version locked and a:b.c:2.0
 * is not version locked - 1.0 & 2.0 are arbitrary versions - this will return a
 * positive index value for a:b.c:1.0 and negative value for a:b.c:2.0.
 */
Integer addVersionLockedPackageToSet(String packageSpecifier,
                                     Map<Integer, Set<String>> lockedPackages,
                                     Set<Integer> blacklist) {
  def index = getVersionLockedPackageIndex(packageSpecifier)
  if (index in blacklist) index = -index
  if (index > 0) {
    def lockedPackageSet = lockedPackages[index]
    if (!lockedPackageSet) {
      lockedPackageSet = [].toSet()
    }
    lockedPackageSet.add(packageSpecifier)
    lockedPackages[index] = lockedPackageSet
  }
  return index
}

/*
 * Given a set of package specs, generate a blacklist of version locked package
 * set indexes.
 *
 * @param packageSpecifiers List of package specifications to scan for
 * version-locked package groups that should be blacklisted.
 *
 * @returns Set of blacklisted package set indexes that for groups of packages
 * that should not be version-locked.
 */
Set<Integer> createVersionLockedSetBlacklist(List<String> packageSpecifiers) {
  def blacklist = [].toSet()
  packageSpecifiers.each { packageSpecifier ->
    def index = getVersionLockedPackageIndex(packageSpecifier)
    if (index < 0) blacklist.add(-index)
  }
  return blacklist
}

/*
 * Generate a map of the most recent version-locked packages each set.
 *
 * @param lockedPackages Sets of version-locked packages indexed by an
 * arbitrary number for grouping.
 *
 * @returns List of packages.
 */
List<String> mostRecentVersionLockedPackagesFromSet(
    Map<Integer, Set<String>> lockedPackages) {
  def versionLockedPackages = []
  lockedPackages.values().each { packages ->
    def versions = packages.collectEntries {
      def version = getComponentsFromPackage(it)[2]
      return [(maxVersionFromVersionExpression(version)): version]
    }
    def highestVersionExpression =
      versions[sortVersionStrings(versions.keySet())[-1]]
    getVersionlessArtifactsByPackage(packages, true).values().sort().each {
      versionLockedPackages.add([it, highestVersionExpression].join(":"))
    }
  }
  return versionLockedPackages
}

/*
 * Perform a breadth first walk of a dependency graph optionally calling a
 * closure for each node in the graph.
 *
 * @param root Root of the graph to traverse.
 * @param closure Closure to call for each node in the graph.
 * The closure is called with
 * (DependencyResult dependency, List<DependencyResult> parents)
 * where dependency is the current dependency and parents is the list of
 * parents of the current dependency.  This value can be null to just retrieve
 * a flat list of nodes in the graph.
 *
 * @returns List of (dependency, graph nodes) traversed.
 */
List<List<DependencyResult, List<DependencyResult>>>
    walkResolvedComponentResultGraph(ResolvedComponentResult root, closure) {
  // List of (dependency, parentsList) tuples where dependency is a
  // DependencyResult describing a node in the graph and parentsList is the
  // list of DependencyResult nodes that are parents of the "dependency" node.
  def graphRemaining = []
  root.dependencies.each { graphRemaining.add([it, []]) }

  def summaryGraph = []
  // Map of versionless package names to versioned package specification
  // strings.
  while (graphRemaining.size > 0) {
    // Process current node in the graph.
    def (dependency, parents) = graphRemaining[0]
    summaryGraph.add(graphRemaining[0])
    graphRemaining = graphRemaining.drop(1)

    // Call the closure the current node and the current node's parents.
    if (closure) closure(dependency, parents)

    def componentResult = dependency.selected
    def parentsOfChildren = parents.clone()
    parentsOfChildren.addAll(0, [dependency])
    def children = []
    componentResult.dependencies.each {
      children.add([it, parentsOfChildren])
    }
    graphRemaining.addAll(0, children)
  }
  return summaryGraph
}

/*
 * Walk a dependency graph loosing the version constraints for the parent of
 * each conflicting dependency.
 *
 * This walks the supplied graph and loosens the version constraints using
 * loosenVersionExpression() for each parent of a conflicting dependency.
 * The method returns a map of package strings that can be used in another
 * attempt to resolve without conflicts.
 *
 * @param root Root of the graph to traverse.
 * @param requestedPackages Set of package dependency strings that were used
 * to generate the resolved dependency graph.
 * @param applyToTransitiveDependencies Whether to loosen and override version
 * requirements of transitive dependencies.
 *
 * @returns Tuple of [conflictsFound, packages] where
 * "conflictsFound" is a boolean that indicates whether any conflicting
 * packages were found in the graph and "packages" is a set of package
 * dependency strings from the set requestedPackages with potentially loosened
 * version constraints.
 */
def loosenVersionContraintsForConflicts(ResolvedComponentResult root,
                                        Set<String> requestedPackages,
                                        boolean applyToTransitiveDependencies) {
  // NOTE: The version field is ignored in the returned map, this is only used
  // to look up the type specifier for each package.
  def requestedPackagesByVersionlessArtifacts =
    getPackagesByVersionlessArtifact(requestedPackages)
  def versionlessPackages =
    requestedPackagesByVersionlessArtifacts.keySet().toSet()

  // Build a set of version locked package set indexes that should not be
  // version locked.
  def versionLockedSetBlacklist = createVersionLockedSetBlacklist(
    walkResolvedComponentResultGraph(root, null).collect {
      dependency, parents ->
        moduleComponentSelectorToString(dependency.requested as
                                        ModuleComponentSelector)
    })

  def packages = [:]
  def versionLockedPackages = [:]

  // Closure which adds a dependency to the packages map if it is present in
  // the versionlessPackages set.
  def addDependencyToPackages = { dependency, isConflicting ->
    def packageSpec = moduleComponentSelectorToString(
      dependency.requested as ModuleComponentSelector)
    def (group, artifact, versionExpression, artifactType) =
      getComponentsFromPackage(packageSpec)
    def versionlessPackageName = [group, artifact].join(":")

    // ModuleComponentSelector does not include the artifact type so this is
    // derived from the requested packages.
    def requestedPackage =
      requestedPackagesByVersionlessArtifacts[versionlessPackageName]
    if (requestedPackage) {
      artifactType = getComponentsFromPackage(requestedPackage)[3]
    }

    // If the package is version-locked add it to the tracking set so it can
    // be reconciled later.
    if (addVersionLockedPackageToSet(packageSpec, versionLockedPackages,
                                     versionLockedSetBlacklist) > 0) {
      return
    }

    // If this package wasn't specified by the user, ignore it.
    if (!(versionlessPackageName in versionlessPackages)) {
      return
    }
    // Loosen the version expression for this package if it is currently
    // conflicting.
    def selectedVersionExpression =
      isConflicting ? loosenVersionExpression(versionExpression) :
        versionExpression

    // If an existing version has been enumerated, pick the most recent
    // version.
    def existingPackageSpec = packages[versionlessPackageName]
    if (existingPackageSpec) {
      def existingVersionExpression =
        getComponentsFromPackage(existingPackageSpec)[2]
      if (existingVersionExpression) {
        def versionsBySortingKey = [
          existingVersionExpression,
          selectedVersionExpression
        ].collectEntries {
          [(maxVersionFromVersionExpression(it)): it]
        }
        def maxVersionExpression =
          versionsBySortingKey[sortVersionStrings(
              versionsBySortingKey.keySet())[-1]]
        selectedVersionExpression = maxVersionExpression
      }
    }
    def newPackageSpec =
      [versionlessPackageName, selectedVersionExpression].join(":") +
        (artifactType ? "@" + artifactType : "")
    packages[versionlessPackageName] = newPackageSpec
  }

  def conflictsFound = false
  def summaryGraph = walkResolvedComponentResultGraph(
    root, { dependency, parents ->
      def componentResult = dependency.selected

      // Get the versionless name of this dependency.
      def (dependencyGroup, dependencyArtifact,
           dependencyVersionExpression, dependencyArtifactType) =
        getComponentsFromPackage(
          moduleComponentSelectorToString(
            dependency.requested as ModuleComponentSelector))
      def dependencyVersionlessPackageName =
        [dependencyGroup, dependencyArtifact].join(":")

      def isConflicting = componentResult.selectionReason.isConflictResolution()
      // This is only a conflict if the user did not explicitly specify this
      // dependency.  This allows users to resolve conflicts manually.
      isConflicting &= !(dependencyVersionlessPackageName in
                         versionlessPackages)
      conflictsFound |= isConflicting
      addDependencyToPackages(dependency, isConflicting)
      if (isConflicting) parents.each { addDependencyToPackages(it, true) }

      def overrideTransitiveDependencies =
        applyToTransitiveDependencies &&
        (dependency.requested as ModuleComponentSelector).version == "+"

      componentResult.dependencies.each {
        // If the parent's version expression can't be loosened any further,
        // start overriding the selected version of each transitive
        // dependency.
        if (overrideTransitiveDependencies) {
          def packageSpec = moduleComponentSelectorToString(
            it.requested as ModuleComponentSelector)
          def versionlessName = getVersionlessArtifactByPackage(packageSpec,
                                                                true)
          if (!(versionlessName in versionlessPackages)) {
            packages[versionlessName] = packageSpec
            versionlessPackages.add(versionlessName)
            logger.info(sprintf("Overriding transitive dependency %s",
                                packageSpec))
          }
        }
      }
    })

  // Select the most recent version of each version-locked package and add to
  // the set.
  packages += mostRecentVersionLockedPackagesFromSet(
      versionLockedPackages).collectEntries {
    [(getVersionlessArtifactByPackage(it, true)): it]
  }

  logger.info("=== Updated Dependencies ===")
  summaryGraph.each {
    def (dependency, parents) = it
    logger.info(
      sprintf("%s* %s (new: %s, conflicting: %b (parents: %s))",
              "  ".multiply(parents.size()),
              dependency.toString(),
              packages[getVersionlessArtifactByPackage(
                  moduleComponentSelectorToString(
                    dependency.requested as ModuleComponentSelector), true)],
              dependency.selected.selectionReason.isConflictResolution(),
              parents.collect {
                moduleComponentSelectorToString(
                  it.requested as ModuleComponentSelector)
              }))
  }

  logger.info(sprintf("=== Selected dependencies: %s", packages.toString()))

  return [conflictsFound, packages.values().toSet()]
}

/*
 * Given two sets of package specifications that specify potentially different
 * versions, create a map that describes all versions that have changed.
 *
 * @param oldPackages Package specifications prior to the version change.
 * @param newPackages Package specifications after the version change.
 *
 * @returns Map of [oldVersion, newVersion] tuples indexed by the versionless
 * package name for each package with a modified version.
 */
Map<String, List<String>> getModifiedPackageVersions(
    Iterable<String> oldPackages, Iterable<String> newPackages) {
  // Track package specifications that were modified.
  def packagesModified = [:]
  def oldPackagesByVersionlessName =
    getPackagesByVersionlessArtifact(oldPackages)
  def newPackagesByVersionlessName =
    getPackagesByVersionlessArtifact(newPackages)
  oldPackagesByVersionlessName.each { versionlessName, oldVersion ->
    def newVersion = newPackagesByVersionlessName[versionlessName]
    if (normalizeVersion(getComponentsFromPackage(newVersion)[2]) !=
        normalizeVersion(getComponentsFromPackage(oldVersion)[2])) {
      packagesModified[versionlessName] = [oldVersion, newVersion]
    }
  }
  return packagesModified
}

/*
 * Attempt resolution of the specified packages, loosening version constraints
 * if resolution fails due to conflict package versions.
 *
 * @param packages Packages to resolve the dependencies of.
 *
 * @returns A tuple of [packages, packagesModified, configuration]
 * where:
 * - packages is a List of package specifications that were successfully resolved
 *   or the original package list if it's not possible to find a set of packages that
 *   do not conflict.
 * - packagesModified is the value returned by getModifiedPackageVersions()
 *   the change between the supplied packages.
 * - configuration is the gradle Configuration used to resolve the packages.
 */
def resolveConflictingPackages(Iterable<String> packages) {
  def currentPackages = packages.clone()
  def resolutionAttempt = 1
  def userPackagesToQuery = null
  while (true) {
    // Copy the configuration to query the set of required dependencies.
    userPackagesToQuery = project.configurations.create(
      "userPackagesToQuery" + resolutionAttempt.toString())
    // Add user specified packages to the userPackages configuration.
    // This allows us to resolve during the configuration phase.
    logger.info(sprintf("Resolution attempt %d: packages %s",
                        resolutionAttempt, currentPackages.toString()))
    currentPackages.each {
      project.dependencies.add(userPackagesToQuery.name, it)
    }
    try {
      userPackagesToQuery.resolve()
    } catch (ResolveException e) {
      // If a package is missing, don't continue searching as the overall
      // resolution process will fail anyway.
      logger.info(sprintf("Resolution failed %s (%s) for packages %s",
                          e.toString(), e.getCauses().toString(),
                          currentPackages.toString()))
      break
    }
    def (conflictsFound, newPackages) = loosenVersionContraintsForConflicts(
      userPackagesToQuery.incoming.resolutionResult.root, currentPackages,
      true)
    def packagesChanged = !newPackages.equals(currentPackages)
    currentPackages = newPackages
    logger.info(sprintf("Resolution attempt: %d, conflicts: %b, " +
                        "updated packages: %b", resolutionAttempt,
                        conflictsFound, packagesChanged))
    if (!conflictsFound) {
      break
    } else if (!packagesChanged) {
      logger.warn(sprintf("Unable to find a set of non-conflicting artifacts " +
                          "for packages %s.", packages.toString()))
      break
    }
    resolutionAttempt++
  }
  return [currentPackages,
          getModifiedPackageVersions(packages, currentPackages),
          userPackagesToQuery]
}

/*
 * For each missing package search for a srcaar artifact.
 *
 * JarResolverLib will implicitly search for .srcaar artifacts in a maven
 * package in addition to aar and jar artifacts.  Since Gradle doesn't know
 * what a srcaar is and it's likely each POM doesn't reference the srcaar
 * either, we resolve dependencies during the configuration phase to
 * determine which packages are missing, add the srcaar artifact specifier
 * to search for srcaar files then search again in an attempt to resolve
 * the missing packages.
 *
 * @param packages Package specifications to resolve.
 *
 * @returns Package specifications with the @srcaar artifact specifier for each
 * artifact where a fallback package exists.
 */
Set<String> fallbackToSrcAarArtifacts(Iterable<String> packages) {
  def allPackages = getPackagesByVersionlessArtifact(packages)

  // Search for all packages, excluding those with explicit artifact types and
  // find the missing set.
  def searchPackages = allPackages.findAll { !it.value.contains("@") }
  def findMissingConfig = project.configurations.create("findMissing")
  packages.each { project.dependencies.add(findMissingConfig.name, it) }
  def foundArtifacts = getVersionlessArtifactFilenames(
    findMissingConfig.resolvedConfiguration.
      lenientConfiguration.getArtifacts(Specs.satisfyAll()), true)
  def missingPackages = searchPackages.keySet().minus(foundArtifacts)
  def fallbackPackages = missingPackages.collectEntries {
    [it, searchPackages[it] + "@srcaar"]
  }

  // Search for missing packages using the srcaar artifact type.
  def searchForSrcAarConfig = project.configurations.create("searchForSrcAars")
  fallbackPackages.values().each {
    project.dependencies.add(searchForSrcAarConfig.name, it)
  }
  foundArtifacts = getVersionlessArtifactFilenames(
    searchForSrcAarConfig.resolvedConfiguration.
      lenientConfiguration.getArtifacts(Specs.satisfyAll()), true)

  // Replace all user supplied packages in the output set with discovered srcaar
  // package specs.
  def outputPackages = [].toSet()
  packages.each {
    def versionlessArtifact =
      getVersionlessArtifactByPackage(it, true)
    if (versionlessArtifact && versionlessArtifact in foundArtifacts) {
      outputPackages.add(fallbackPackages[versionlessArtifact])
    } else {
      outputPackages.add(it)
    }
  }
  return outputPackages
}

def testGetComponentsFromPackage() {
  [["org.test.psr:something-neat:1.2.3@special",
    ["org.test.psr", "something-neat", "1.2.3", "special"]],
   ["org.test.psr:something-neat:1.2.3",
    ["org.test.psr", "something-neat", "1.2.3", null]],
   ["org.test.psr:something-neat",
    ["org.test.psr", "something-neat", null, null]],
   ["org.test.psr", ["org.test.psr", null, null, null]],
   ["", [null, null, null, null]]].each { packageSpecifier, expected ->
     def result = getComponentsFromPackage(packageSpecifier)
     if (result != expected) {
       throw new Exception(
         sprintf("Invalid components %s, expected %s for package '%s'",
                 result, expected, packageSpecifier))
     }
  }
}

def testGetVersionlessArtifactByPackage() {
  [["org.test.psr:something-neat:1.2.3", true,
    "org.test.psr:something-neat"],
   ["org.test.psr:something-neat:1.2.3", false,
    "org.test.psr.something-neat"],
   ["just.a.group", false, null]].each {
    def (packageSpecifier, colonAsSeparator, expected) = it
    def result = getVersionlessArtifactByPackage(packageSpecifier,
                                                 colonAsSeparator)
    if (result != expected) {
      throw new Exception(
        sprintf("Invalid versionless artifact %s, expected %s for [%s, %b]",
                result, expected, packageSpecifier, colonAsSeparator))
    }
  }
}

def testGetVersionlessArtifactsByPackage() {
  [[["a.b.c:d-e:1.2.3", "a.b.c:e-f:+", "a.b.c"], false,
    ["a.b.c:d-e:1.2.3": "a.b.c.d-e",
     "a.b.c:e-f:+": "a.b.c.e-f"]],
   [["a.b.c:d-e:1.2.3", "a.b.c:e-f:+", "a.b.c"], true,
    ["a.b.c:d-e:1.2.3": "a.b.c:d-e",
     "a.b.c:e-f:+": "a.b.c:e-f"]]].each {
    packages, colonAsSeparator, expected ->
      def result = getVersionlessArtifactsByPackage(packages, colonAsSeparator)
      if (result != expected) {
        throw new Exception(
          sprintf("Unexpected map %s, expected %s for %s",
                  result.toString(), expected.toString(),
                  [packages, colonAsSeparator].toString()))
      }
  }
}

def testGetPackagesByVersionlessArtifact() {
  [[["a.b.c:d-e:1.2.3", "a.b.c:e-f:+"],
    ["a.b.c:d-e": "a.b.c:d-e:1.2.3",
     "a.b.c:e-f": "a.b.c:e-f:+"]],
   [["a.b.c:d-e:1.2.+", "a.b.c:d-e:2.1.+"],
    ["a.b.c:d-e": "a.b.c:d-e:2.1.+"]]].each { packages, expected ->
    def result = getPackagesByVersionlessArtifact(packages)
    if (result != expected) {
      throw new Exception(
        sprintf("Unexpected map %s, expected %s for %s",
                result.toString(), expected.toString(),
                packages.toString()))
    }
  }
}

def testLoosenVersionExpression() {
  ["1.2.3": "1.2.3+",
   "1.2.3+": "1.2.+",
   "1.2.+": "1.2+",
   "1.2+": "1.+",
   "1.+": "1+",
   "1+": "+",
   "[1.2.3,4.5.6)": "1.2.3+",
   "[1.2.+,4.5.6]": "1.2+",
   "[1.2.3]": "1.2.3+",
   "[1.2.+]": "1.2+",
   "[1.+]": "1+"].each { expression, expected ->
     def result = loosenVersionExpression(expression)
     if (result != expected) {
       throw new Exception(
         sprintf("Invalid loose version expression %s, " +
                 "expected %s for %s", result, expected, expression))
     }
  }
}

def testGetVersionLockedPackageIndex() {
  ["com.google.android.gms:play-services-base:12.0.1": 1,
   "com.google.firebase:firebase-core:12.0.1": 1,
   "com.android.support:support-v4:23.0.+": 2,
   "com.google.firebase:firebase-app-unity:4.3.0": 0,
   "com.google.android.gms:play-services-base:15.1.2": -1].each {
    packageSpec, expectedIndex ->
      def index = getVersionLockedPackageIndex(packageSpec)
      logger.info(sprintf("package %s (%d vs %d)",
                          packageSpec, index, expectedIndex))
      if (index != expectedIndex) {
        throw new Exception(
          sprintf("Invalid package lock %d, expected %d for %s",
                  index, expectedIndex, packageSpec))
      }
  }
}

def testAddVersionLockedPackageToSet() {
  def lockedPackages = [:]
  [["com.google.android.gms:play-services-base:12.0.1", true],
   ["com.google.firebase:firebase-core:12.0.1", true],
   ["com.android.support:support-v4:23.0.+", true],
   ["com.android.support:support-vector-drawable:24+", true],
   ["com.google.firebase:firebase-app-unity:4.3.0", false],
   ["com.google.android.gms:play-services-base:15.1.2", false]].each {
    packageSpecifier, expected ->
      def resultIndex = addVersionLockedPackageToSet(packageSpecifier,
                                                     lockedPackages, [].toSet())
      def result = resultIndex > 0
      if (expected != result) {
        throw new Exception(
          sprintf("%s was incorrectly added to a version-locked set, " +
                  "returned %b, expected %b", packageSpecifier, result,
                  expected))
      }
  }
  def expectedLockedPackages =
    [1: ["com.google.android.gms:play-services-base:12.0.1",
         "com.google.firebase:firebase-core:12.0.1"].toSet(),
     2: ["com.android.support:support-v4:23.0.+",
         "com.android.support:support-vector-drawable:24+"].toSet()]
  if (lockedPackages != expectedLockedPackages) {
    throw new Exception(
      sprintf("Generated invalid set of locked packages %s, expected %s",
              lockedPackages.toString(), expectedLockedPackages.toString()))
  }
}

def testCreateVersionLockedSetBlacklist() {
  def expectedBlacklist = [1].toSet()
  def blacklist = createVersionLockedSetBlacklist(
    ["com.google.android.gms:play-services-base:12.0.1",
     "com.google.firebase:firebase-core:12.0.1",
     "com.google.android.gms:play-services-base:15.+",
     "com.android.support:support-v4:23.0.+"])
  if (blacklist != expectedBlacklist) {
    throw new Exception(
      sprintf("Created invalid blacklist of locked package groups %s, " +
              "expected %s", blacklist, expectedBlacklist))
  }
}

def testAddVersionLockedPackageToSetWithBlacklist() {
  def blacklist = [1].toSet()
  def lockedPackages = [:]
  ["com.google.android.gms:play-services-base:12.0.1": -1,
   "com.google.firebase:firebase-core:12.0.1": -1,
   "com.android.support:support-v4:23.0.+": 2].each {
    packageSpec, expectedIndex ->
      def resultIndex = addVersionLockedPackageToSet(packageSpec,
                                                     lockedPackages,
                                                     blacklist)
      if (resultIndex != expectedIndex) {
        throw new Exception(
          sprintf("%s was incorrectly added to a version-locked set, " +
                  "return %d, expected %d", packageSpec, resultIndex,
                  expectedIndex))
      }
  }
}

def testMostRecentVersionLockedPackagesFromSet() {
  def versionLockedSets = [
    1: ["com.google.android.gms:play-services-base:12.0.1",
        "com.google.firebase:firebase-core:12.0.+"].toSet(),
    2: ["com.android.support:support-v4:23.0.+",
        "com.android.support:support-vector-drawable:24.+"].toSet()]
  def versionLockedList =
    mostRecentVersionLockedPackagesFromSet(versionLockedSets)
  def expectedPackageList = [
    "com.google.android.gms:play-services-base:12.0.+",
    "com.google.firebase:firebase-core:12.0.+",
    "com.android.support:support-v4:24.+",
    "com.android.support:support-vector-drawable:24.+"
  ]
  if (versionLockedList != expectedPackageList) {
    throw new Exception(
      sprintf("Invalid version-locked packages %s, expected %s " +
              "given %s", versionLockedList, expectedPackageList,
              versionLockedSets))
  }
}

def testGetModifiedPackageVersions() {
  def oldPackages = ["a.b.c:e-f:1.2.3", "a.b.c:f-h:4.5.6", "e.f.g:a-b:[0.1.0]",
                     "e.f.g:a-b:0.1.0"]
  def newPackages = ["a.b.c:e-f:1.3.0", "a.b.c:f-h:4.6.2", "e.f.g:a-b:0.1.0",
                     "e.f.g:a-b:[0.1.0]"]
  def expectedModifiedPackages = [
    "a.b.c:e-f": ["a.b.c:e-f:1.2.3", "a.b.c:e-f:1.3.0"],
    "a.b.c:f-h": ["a.b.c:f-h:4.5.6", "a.b.c:f-h:4.6.2"],
  ]
  def modifiedPackages = getModifiedPackageVersions(oldPackages, newPackages)
  if (modifiedPackages != expectedModifiedPackages) {
    throw new Exception(
      sprintf("Invalid modified packages %s, expected %s for %s",
              modifiedPackages, expectedModifiedPackages,
              [oldPackages, newPackages]))
  }
}

def testSortVersionStrings() {
  def unsorted = ["1.2.3", "1.2", "3.2", "5", "0.1.2"]
  def expected = ["0.1.2", "1.2", "1.2.3", "3.2", "5"]
  def result = sortVersionStrings(unsorted)
  if (result != expected) {
    throw new Exception(
      sprintf("Version sorting failed %s, expected %s for %s",
              result, expected, unsorted))
  }
}

// Run unit tests
// TODO(b/79267099): Factor the tests out of this script.
def runTests() {
  testGetComponentsFromPackage()
  testGetVersionlessArtifactByPackage()
  testGetVersionlessArtifactsByPackage()
  testGetPackagesByVersionlessArtifact()
  testLoosenVersionExpression()
  testGetVersionLockedPackageIndex()
  testAddVersionLockedPackageToSet()
  testCreateVersionLockedSetBlacklist()
  testAddVersionLockedPackageToSetWithBlacklist()
  testMostRecentVersionLockedPackagesFromSet()
  testGetModifiedPackageVersions()
  testSortVersionStrings()
}

// Configure project properties.
project.ext {
  // List of tasks that copy artifacts.
  copyTasks = []
  // List of copied file and the associated artifact tuples.
  copiedFileArtifacts = []
  // Set of packages to copy, exposed to the copyPackages task.
  packagesToCopy = [].toSet()
  // Set of packages with modified versions due to conflicting dependencies.
  // Maps the versionless package name to a tuple of (oldVersion, newVersion)
  packagesModified = [:]

  if (project.hasProperty("RUN_TESTS")) {
    runTests()
    return
  }

  // Get the install location of the Android SDK.
  def sdkRoot = null
  for (prop in [System.getProperty("ANDROID_HOME"),
                project.hasProperty("ANDROID_HOME") ?
                  getProperty("ANDROID_HOME") : null,
                System.getenv("ANDROID_HOME")]) {
    if (prop) {
      sdkRoot = prop
      break
    }
  }
  if (sdkRoot) {
    logger.info("ANDROID_HOME: " + sdkRoot)
  }
  androidSdkRoot = sdkRoot

  def mavenUris = []
  // Retrieve a list of command line specified maven repo URIs.
  if (project.hasProperty("MAVEN_REPOS")) {
    project.getProperty("MAVEN_REPOS").tokenize(";").each {
      mavenUris.push(new URI(it))
    }
  }

  def useMavenLocalRepo = true
  if (project.hasProperty("USE_MAVEN_LOCAL_REPO")) {
    useMavenLocalRepo = project.getProperty("USE_MAVEN_LOCAL_REPO") == "1"
  }
  def useRemoteMavenRepos = true
  if (project.hasProperty("USE_REMOTE_MAVEN_REPOS")) {
    useRemoteMavenRepos = project.getProperty("USE_REMOTE_MAVEN_REPOS") == "1"
  }

  // Construct a list of local Maven URIs in the Android SDK.
  if (androidSdkRoot) {
    ["extras/android/m2repository", "extras/google/m2repository"].each {
      def path = new File(androidSdkRoot, it)
      if (path.exists()) mavenUris.push(path.toURI())
    }
  }
  // Add Google maven repositories.
  if (useRemoteMavenRepos) {
    mavenUris.push(new URI("https://maven.google.com"))
  }

  // List of URIs to add to the set of maven sources.
  mavenRepoUris = mavenUris

  // Add the repositories here so that we can resolve during configuration
  // below.
  project.repositories {
    for (uri in mavenRepoUris) {
      maven {
        url uri
      }
    }
    if (useMavenLocalRepo) mavenLocal()
    if (useRemoteMavenRepos) {
      jcenter()
      mavenCentral()
    }
  }

  project.repositories.each {
    logger.info(sprintf("MAVEN_REPOS: name=%s url=%s", it.name, it.url))
  }

  // Set of packages to copy to the target directory.
  if (!project.hasProperty("PACKAGES_TO_COPY")) {
    print helpText
    logger.error("Project property PACKAGES_TO_COPY must be specified.")
    System.exit(1)
  }
  Set packages = project.getProperty("PACKAGES_TO_COPY").tokenize(";")
  packages.each { logger.info("PACKAGES_TO_COPY: " + it) }

  // Location to copy referenced packages.
  if (!project.hasProperty("TARGET_DIR")) {
    print helpText
    logger.error("Project property TARGET_DIR must be specified.")
    System.exit(1)
  }
  targetDir = project.getProperty("TARGET_DIR")
  logger.info("TARGET_DIR: " + (new File(targetDir).absolutePath).toString())

  // Fallback to search for srcaar artifacts when an artifact is missing.
  packages = fallbackToSrcAarArtifacts(packages)

  // Resolve while searching for a set of non-conflicting package
  // specifications.
  def userPackagesToQuery
  (packages, packagesModified, userPackagesToQuery) =
    resolveConflictingPackages(packages)

  def versionlessArtifactByPackage = getVersionlessArtifactsByPackage(packages)

  // Resolve the current set of packages including any srcaar packages injected
  // in packagesToCopyByUserPackages.
  def resolvedArtifacts = userPackagesToQuery.resolvedConfiguration.
    lenientConfiguration.getArtifacts(Specs.satisfyAll())

  // If we were unable to find a set of packages with versions that do not
  // conflict we may still end up with transitive references to artifacts at
  // different versions which should all point at the same version.  So,
  // if possible, iterate through all fetched artifacts and explicitly pin all
  // version-locked transitive dependencies to the same version.
  def versionLockedPackageSets = [:]
  def previousVersionLockedPackages = [].toSet()
  def versionLockedSetBlacklist = createVersionLockedSetBlacklist(
    resolvedArtifacts.collect {
      resolvedModuleVersionToPackage(it.moduleVersion)
    })
  resolvedArtifacts.each {
    def packageSpec = resolvedModuleVersionToPackage(it.moduleVersion)
    if (addVersionLockedPackageToSet(packageSpec,
                                     versionLockedPackageSets,
                                     versionLockedSetBlacklist) > 0) {
      previousVersionLockedPackages.add(packageSpec)
      return
    }
    packagesToCopy.add(resolvedArtifactToPackage(it))
  }

  // Lock each resolved packages to the most recent version.
  def versionLockedPackages = mostRecentVersionLockedPackagesFromSet(
    versionLockedPackageSets)
  packagesToCopy += versionLockedPackages.toSet()
  // Update packagesModified to track changed package version retaining the
  // original version of each modified package.
  getModifiedPackageVersions(previousVersionLockedPackages,
                             versionLockedPackages).each {
    versionlessName, versions ->
      existingVersions = packagesModified[versionlessName]
      packagesModified[versionlessName] =
        existingVersions ? [existingVersions[0], versions[1]] : versions
  }

  // Scan for user specified artifacts that were not resolved and add them to
  // the list of packages to copy so they can be reported as missing.
  def foundArtifacts = getPackagesByVersionlessArtifact(packagesToCopy)
  getPackagesByVersionlessArtifact(versionlessArtifactByPackage.keySet()).each {
    if (!foundArtifacts.keySet().contains(it.key)) {
      packagesToCopy.add(it.value)
    }
  }

  packagesToCopy.each {
    // Add final set of packages to copy to the copyPackagesConfig
    // configuration.
    project.dependencies.copyPackagesConfig it
  }

  // Resolve the final set of artifacts to copy.
  def artifactsToCopy = project.configurations.copyPackagesConfig.
    resolvedConfiguration.lenientConfiguration.getArtifacts(Specs.satisfyAll())

  // Generate tasks to copy each artifact to a unique filename in the target
  // directory.
  artifactsToCopy.each {
    def artifact = it
    def packageType = artifact.type
    def packageSpecifier = resolvedArtifactToPackage(artifact)
    def artifactTargetFilename =
      sprintf("%s-%s.%s",
              getVersionlessArtifactByPackage(packageSpecifier),
              artifact.moduleVersion.id.version,
              packageType == "srcaar" ? "aar" : packageType)
    artifactTargetFile = new File(targetDir,
                                  artifactTargetFilename)
    if (artifactTargetFile.exists()) {
      // If the target file already exists simply report it as copied.
      copiedFileArtifacts.add([artifactTargetFile, artifact])
    } else {
      // If the target file does not exist generate a task to copy it.
      def copyTask = tasks.create(
        name: "copy_" + artifactTargetFilename,
          type: Copy,
          description: sprintf("Copy %s (%s) to %s", packageSpecifier,
                               artifact.file, artifactTargetFilename))
      copyTask.with {
        from artifact.file
        into targetDir
        rename(
          // Rename the file to the target filename and log the copied file &
          // artifact so that they can be summarized when all copy artifact
          // tasks are complete.
          {
            String filename ->
              copiedFileArtifacts.add([new File(artifactTargetFilename),
                                       artifact])
              return artifactTargetFilename
          }
        )
        doFirst { logger.info(description) }
      }
      copyTasks.add(copyTask)
    }
  }
}

// Task which depends upon all copy package tasks and summarizes the set of
// copied files when it's complete, displaying:
// * The set of files copied into the target directory.
// * The dependency expression for each artifact that was not found.
// * Any packages that were modified from the dependency expression specified
//   by the user.
task copyPackages(dependsOn: project.ext.copyTasks) {
  doLast {
    def copiedFileArtifacts = project.ext.copiedFileArtifacts
    def copiedArtifacts = []
    if (copiedFileArtifacts) {
      println "Copied artifacts:"
      copiedFileArtifacts.collect { it[0].name }.toSorted().each { println it }
      println ""
      copiedFileArtifacts.each { copiedArtifacts.add(it[1]) }
    }
    def resolvedVersionlessArtifacts = getVersionlessArtifactFilenames(
      copiedArtifacts)
    def versionlessArtifactByPackage = getVersionlessArtifactsByPackage(
      project.ext.packagesToCopy)
    def missingPackages = []
    versionlessArtifactByPackage.each {
      if (!resolvedVersionlessArtifacts.contains(it.value)) {
        missingPackages.push(it.key)
      }
    }
    if (missingPackages) {
      println "Missing artifacts:"
      missingPackages.toSorted().each { println it }
      println ""
    }
    def packagesModified = project.ext.packagesModified
    if (packagesModified) {
      println "Modified artifacts:"
      packagesModified.values().toSorted().each {
        println it[0] + " --> " + it[1]
      }
      println ""
    }
  }
}

project.defaultTasks = ["copyPackages"]
